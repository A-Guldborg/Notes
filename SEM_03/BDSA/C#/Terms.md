# Terms

|Term|Explanation|
|---|---|
|Value types (struct)|Integers, characters or classes defined with keyword struct which always has a certain memory allocation. Copying a value type variable and changing the new (copied) version does not change the original, as the copied version has its own memory allocation. Takes up exactly the memory that the fields use.<br>An array of structs will be initialized where each field it holds is accessible.|
|Passing arguments by value|When a method uses an argument of a value type, a local variable is created and thus the argument variable is a copy of the value passed. If the value changes within the method, it has no effect on the variable that was passed to the function outside of the method.<br>The work-around is to pass the argument with the ref modifier, by both putting the ref keyword in the method signature and when the method is called. This way, the value will be treated like a reference.|
|Reference types (class)|Strings, regular classes, arrays etc. that have a dynamic memory need. This means that the variable holds a reference to a place in the memory that stores the variable. Copying a reference type variable and changing the new (copied) version also changes the original, as they both point to the same memory allocation. Takes up memory for the fields and an object overhead once and then memory for each reference. <br> An array of a class will be initialized as an array of null references.|
|Passing arguments by reference|When a method uses a reference type as an argument, the reference is copied and thus changing the instance that is referenced will also have an effect on the argument outside the scope of the method.<br> Changing the reference doesn’t affect the object outside the scope of the method, and thus changing the reference to null will not delete the object outside the scope of the method.|
|Multiple return values|A function always returns either void or one value/reference, but a work-around to this is by using the argument modifier “out”. Like the modifier “ref”, it is put both in the function signature and function call, and means that any value is changed like a reference.<br> While the value need not be assigned before entering the method, it must be assigned before the end of the method.<br> If there is an argument value that is not necessary where the function is called, the parameter can be called as an underscore (without the type) instead, called a discard. This way the compiler knows to disregard the value.|
|Unmodifiable argument as reference|Passing a reference without changing it can be done by the argument modifier “in”.|
|Dynamic number of arguments|A method doesn’t need an exact number of input parameters/arguments. By using the argument modifier “params” at the final argument which must be declared as a single dimensional array means that the method can be called with 0, 1 or multiple values counting from the final argument. It can also be passed as an array of the correct type instead.|
|Optional parameters|An argument can be optional if a default value is declared by writing an equal sign followed by the default value. This cannot be combined with the ref or out modifiers. Optional parameters must be put after any mandatory parameters.|
|Named arguments|Instead of passing values by the order in the method signature they can be passed as named arguments by declaring the name of the argument in the method call. This can be combined with positional arguments but any named argument must either come in the correct position of the method call or at the very end of the method call. |
|Local references|It is possible to declare a reference to an element in an array or a field in an object, by declaring a variable with the ref modifier before the type and name. Then set it equal to an array index or object field and it is then possible to change the array at the specified index by changing the local ref variable.|
|Target typed new expressions|When it is possible for the compiler to unambiguously determine the type of a variable, it is possible to declare the variable using the keyword `new()` or `new(<value>)` instead of explicitly typing the type alongside the new keyword.|
|Null-Coalescing operator (`??`)|When an operand is followed by a double question mark, the program will check if the value is null and if so, instead return the value on the right of the double question mark, and if the value on the left is not null, return that value.|
|Null-Coalescing assignment operator (`??=`)|A variable can be assigned using two question marks immediately before the equal sign which will only assign the right side to the variable if the variable is currently null. |
|Null-Conditional operator / Elvis operator (`?.`)|Instead of accessing element properties using standard dot notation, adding a question mark before the dot will return null if the element itself is null. This method avoids getting NullReferenceExceptions.<br> The Elvis operator can be repeated by accessing e.g. x?.y?.z and will return null if x, x.y or x.y.z is null. |
|Nullable types|Since values cannot be null, using the Elvis operator to assign an integer variable is not possible since it might return null. <br> Instead it is possible to use the nullable type `int?` instead of int. |
|Signed vs. unsigned integer values|Signed means that the value can be both negative and positive but uses one bit to determine this. Unsigned means that the value can only be positive but does not use this one extra bit. In effect, an int (integer) can thus be between:<br>- Signed: -2<sup>31</sup> to 2<sup>31</sup>-1<br>- Unsigned: 0 to 2<sup>32</sup>-1|
|Stack|A block of memory that stores local variables and parameters, such as the result of a recursive function.|
|Heap|The part of memory that contains objects / reference-type instances. A garbage collector removes objects from the heap when they are no longer referenced by any other “alive” instance.|
